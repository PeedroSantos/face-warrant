<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Recognition System</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Face Recognition System</h1>
            <p>Powered by YOLOv11 and Face Recognition</p>
        </div>

        <div class="mainContent">
            
            <div class="section">
                <h2>‚ûï Add Known Face</h2>
                <div class="formGroup">
                    <label for="faceNameInput">Person's Name:</label>
                    <input type="text" id="faceNameInput" placeholder="Enter the person's name">
                </div>
                <div class="formGroup">
                    <label for="faceImageInput">Select Image:</label>
                    <input type="file" id="faceImageInput" accept="image/*">
                </div>
                <div class="preview-area" id="addFacePreview"></div>
                <button class="btn btn-primary" onclick="addKnownFace()">Add Face to Database</button>
                <div id="addFaceStatus" class="status-message"></div>
                <div class="spinner" id="addFaceSpinner"></div>
            </div>

            
            <div class="section">
                <h2>üñºÔ∏è Recognize Image</h2>
                <div class="formGroup">
                    <label for="recognizeImageInput">Select Image:</label>
                    <input type="file" id="recognizeImageInput" accept="image/*">
                </div>
                <div class="preview-area" id="recognizeImagePreview"></div>
                <button class="btn btn-primary" onclick="recognizeImage()">Recognize Faces</button>
                <div id="imageStatus" class="status-message"></div>
                <div class="spinner" id="imageSpinner"></div>
                <div id="imageResults"></div>
            </div>

            
            <div class="section">
                <h2>üé¨ Recognize Video</h2>
                <div class="formGroup">
                    <label for="recognizeVideoInput">Select Video:</label>
                    <input type="file" id="recognizeVideoInput" accept="video/*">
                </div>
                <button class="btn btn-primary" onclick="recognizeVideo()">Recognize Faces in Video</button>
                <div id="videoStatus" class="status-message"></div>
                <div class="spinner" id="videoSpinner"></div>
                <div id="videoResults"></div>
            </div>

            
            <div class="section">
                <h2>üìπ Webcam Recognition</h2>
                <div class="webcam-container">
                    <img id="webcamStream" class="hidden max-full rounded" alt="Server webcam stream">
                    <p class="muted small">This stream is from the server camera (not your local device). If you expect to use your browser camera, the app needs a client-side implementation using getUserMedia.</p>
                    <div id="cameraStatus" class="status-message info hidden">
                        Initializing camera...
                    </div>
                </div>
                <button class="btn btn-primary" id="webcamBtn" onclick="startWebcam()">Start Webcam</button>
                <button class="btn btn-danger hidden" id="stopWebcamBtn" onclick="stopWebcam()">Stop Webcam</button>
            </div>

            
            <div class="section">
                <h2>üë• Known Faces</h2>
                <button class="btn btn-secondary btn-small" onclick="loadKnownFaces()">Refresh List</button>
                <div id="knownFacesList" class="known-faces-list">
                    <p class="muted">No faces loaded yet. Add a face to get started!</p>
                </div>
                <button class="btn btn-danger btn-small" onclick="clearDatabase()">Clear All Faces</button>
                <div id="dbStatus" class="status-message"></div>
            </div>

            
            <div class="section">
                <h2>‚öôÔ∏è System Status</h2>
                <button class="btn btn-secondary btn-small" onclick="checkHealth()">Check Status</button>
                <button class="btn btn-small" id="healthConfigBtn" title="Configurar status" onclick="toggleHealthConfig()">‚öôÔ∏è</button>
                <div id="healthStatus" class="health-box">
                    <div id="healthSpinner" class="spinner" style="display: none"></div>
                    <div id="healthSimple" class="health-simple">
                        <div id="statusBadge" class="status-badge muted">Unknown</div>
                        <div id="healthChips" class="health-chips">
                            <span class="status-chip" data-type="faces"><span class="chip-icon">üë•</span><strong id="facesChip">0</strong><span class="chip-label">Faces</span></span>
                            <span class="status-chip" data-type="webcam"><span class="chip-icon">üì∑</span><strong id="webcamChip">Unknown</strong><span class="chip-label">Webcam</span></span>
                            <span class="status-chip" data-type="db"><span class="chip-icon">üíæ</span><strong id="dbChip">Unknown</strong><span class="chip-label">DB</span></span>
                            <span class="status-chip" data-type="model"><span class="chip-icon">üß†</span><strong id="modelChip">N/A</strong><span class="chip-label">Model</span></span>
                            <span class="status-chip" data-type="disk"><span class="chip-icon">üóÑÔ∏è</span><strong id="diskChip">N/A</strong><span class="chip-label">Disk</span></span>
                            <span class="status-chip" data-type="uptime"><span class="chip-icon">‚è±Ô∏è</span><strong id="uptimeChip">N/A</strong><span class="chip-label">Uptime</span></span>
                        </div>
                        <div id="healthMetrics" class="health-metrics">
                            <div class="metric">
                                <label>CPU</label>
                                <div class="metric-bar" id="cpuBar"><div class="metric-bar-fill" id="cpuFill" style="width:0%"></div></div>
                            </div>
                            <div class="metric">
                                <label>Memory</label>
                                <div class="metric-bar" id="memBar"><div class="metric-bar-fill" id="memFill" style="width:0%"></div></div>
                            </div>
                        </div>
                    </div>

                    <!-- Config dropdown for showing chips / icon-only mode -->
                    <div id="healthConfig" class="health-config hidden">
                        <label><input type="checkbox" id="cfg_faces"> Faces</label><br>
                        <label><input type="checkbox" id="cfg_webcam"> Webcam</label><br>
                        <label><input type="checkbox" id="cfg_db"> DB</label><br>
                        <label><input type="checkbox" id="cfg_model"> Model</label><br>
                        <label><input type="checkbox" id="cfg_disk"> Disk</label><br>
                        <label><input type="checkbox" id="cfg_uptime"> Uptime</label><br>
                        <label style="display:block;margin-top:8px"><input type="checkbox" id="cfg_icon_only"> Icon-only</label>
                    </div>
                    <div id="healthText" class="mt-10 muted small">Click 'Check Status' to get system information</div>
                </div>
            </div>

            
            <div class="section full-width">
                <h2>‚ÑπÔ∏è How to Use</h2>
                <div class="infoSection">
                    <h4>üöÄ Quick Start:</h4>
                    <ul>
                        <li><strong>Add Known Faces:</strong> Upload a clear photo of a person and give them a name. The system will learn their face.</li>
                        <li><strong>Recognize Image:</strong> Upload an image and the system will detect and identify all faces.</li>
                        <li><strong>Recognize Video:</strong> Upload a video file to analyze and find recognized faces throughout.</li>
                        <li><strong>Live Webcam:</strong> Start your webcam for real-time face detection and recognition.</li>
                    </ul>
                </div>
                <div class="infoSection">
                    <h4>üí° Tips:</h4>
                    <ul>
                        <li>Add multiple photos of the same person for better recognition accuracy.</li>
                        <li>Ensure good lighting when adding faces to the database.</li>
                        <li>The system works best with clear, frontal face images.</li>
                        <li>Processing quality improves with more diverse training images.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // File input preview handlers
    document.getElementById('faceImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    document.getElementById('addFacePreview').innerHTML = 
                        `<img class="max-full rounded" src="${event.target.result}" alt="Preview">`;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('recognizeImageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    document.getElementById('recognizeImagePreview').innerHTML = 
                        `<img class="max-full rounded" src="${event.target.result}" alt="Preview">`;
                };
                reader.readAsDataURL(file);
            }
        });

        // Add Known Face
        async function addKnownFace() {
            const name = document.getElementById('faceNameInput').value.trim();
            const file = document.getElementById('faceImageInput').files[0];
            const statusDiv = document.getElementById('addFaceStatus');
            const spinner = document.getElementById('addFaceSpinner');

            if (!name) {
                showStatus(statusDiv, 'Please enter a name', 'error');
                return;
            }

            if (!file) {
                showStatus(statusDiv, 'Please select an image', 'error');
                return;
            }

            spinner.style.display = 'block';
            const formData = new FormData();
            formData.append('name', name);
            formData.append('file', file);

            try {
                const response = await fetch('/api/add-known-face', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    showStatus(statusDiv, data.message, 'success');
                    document.getElementById('faceNameInput').value = '';
                    document.getElementById('faceImageInput').value = '';
                    document.getElementById('addFacePreview').innerHTML = '';
                    await loadKnownFaces();
                } else {
                    showStatus(statusDiv, data.detail || 'Error adding face', 'error');
                }
            } catch (error) {
                showStatus(statusDiv, 'Error: ' + error.message, 'error');
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Recognize Image
        async function recognizeImage() {
            const file = document.getElementById('recognizeImageInput').files[0];
            const statusDiv = document.getElementById('imageStatus');
            const spinner = document.getElementById('imageSpinner');
            const resultsDiv = document.getElementById('imageResults');

            if (!file) {
                showStatus(statusDiv, 'Please select an image', 'error');
                return;
            }

            spinner.style.display = 'block';
            resultsDiv.innerHTML = '';
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/recognize-image', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    showStatus(statusDiv, `Found ${data.data.total_faces} face(s)`, 'success');
                    displayImageResults(data, resultsDiv);
                } else {
                    showStatus(statusDiv, data.detail || 'Error recognizing image', 'error');
                }
            } catch (error) {
                showStatus(statusDiv, 'Error: ' + error.message, 'error');
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Recognize Video
        async function recognizeVideo() {
            const file = document.getElementById('recognizeVideoInput').files[0];
            const statusDiv = document.getElementById('videoStatus');
            const spinner = document.getElementById('videoSpinner');
            const resultsDiv = document.getElementById('videoResults');

            if (!file) {
                showStatus(statusDiv, 'Please select a video', 'error');
                return;
            }

            spinner.style.display = 'block';
            resultsDiv.innerHTML = '';
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/recognize-video', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok) {
                    showStatus(statusDiv, `Processed ${data.total_frames} frames`, 'success');
                    await displayVideoResults(data, resultsDiv);
                } else {
                    showStatus(statusDiv, data.detail || 'Error recognizing video', 'error');
                }
            } catch (error) {
                showStatus(statusDiv, 'Error: ' + error.message, 'error');
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Webcam Stream
        let webcamStreaming = false;

        async function startWebcam() {
            const stream = document.getElementById('webcamStream');
            const cameraStatus = document.getElementById('cameraStatus');
            const webcamBtn = document.getElementById('webcamBtn');
            const stopBtn = document.getElementById('stopWebcamBtn');

            // Toggle classes instead of inline styles so the `.hidden` CSS rule with !important works properly
            webcamBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
            stream.classList.remove('hidden');
            cameraStatus.classList.remove('hidden');
            cameraStatus.classList.remove('error');
            cameraStatus.classList.add('info');
            cameraStatus.textContent = 'Initializing camera...';

            // Attach error and load handlers
            stream.onerror = () => {
                cameraStatus.classList.remove('info');
                cameraStatus.classList.add('error');
                cameraStatus.textContent = 'Failed to start webcam. The server camera might be unavailable.';
                // Restore UI
                stream.classList.add('hidden');
                webcamBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                webcamStreaming = false;
            };
            stream.onload = () => {
                cameraStatus.classList.remove('info');
                cameraStatus.classList.add('success');
                cameraStatus.textContent = 'Webcam streaming.';
            };

            try {
                // Check availability first to provide friendlier error feedback
                const statusResp = await fetch('/api/webcam-status');
                if (statusResp.ok) {
                    const statusData = await statusResp.json();
                    if (!statusData.available) {
                        throw new Error('Server camera is not available');
                    }
                }

                stream.src = '/api/webcam-stream';
                webcamStreaming = true;
            } catch (error) {
                cameraStatus.className = 'status-message error';
                cameraStatus.textContent = 'Error: ' + error.message;
                // Restore UI
                stream.classList.add('hidden');
                webcamBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
                webcamStreaming = false;
            }
        }

        async function stopWebcam() {
            const stream = document.getElementById('webcamStream');
            const cameraStatus = document.getElementById('cameraStatus');
            const webcamBtn = document.getElementById('webcamBtn');
            const stopBtn = document.getElementById('stopWebcamBtn');

            try {
                await fetch('/api/stop-webcam', { method: 'POST' });
                stream.src = '';
                stream.onerror = null;
                stream.onload = null;
                stream.classList.add('hidden');
                cameraStatus.classList.add('hidden');
                webcamStreaming = false;
                webcamBtn.classList.remove('hidden');
                stopBtn.classList.add('hidden');
            } catch (error) {
                console.error('Error stopping webcam:', error);
            }
        }

        // Load Known Faces
        async function loadKnownFaces() {
            try {
                const response = await fetch('/api/known-faces');
                const data = await response.json();
                const list = document.getElementById('knownFacesList');

                if (data.count === 0) {
                    list.innerHTML = '<p class="muted">No faces in database. Add a face to get started!</p>';
                } else {
                    list.innerHTML = data.known_faces
                        .map(name => `<div class="face-badge">${name}</div>`)
                        .join('');
                }
            } catch (error) {
                console.error('Error loading known faces:', error);
            }
        }

        // Clear Database
        async function clearDatabase() {
            if (confirm('Are you sure you want to delete all known faces? This cannot be undone!')) {
                try {
                    const response = await fetch('/api/clear-database', { method: 'POST' });
                    const data = await response.json();
                    showStatus(document.getElementById('dbStatus'), data.message, 'success');
                    await loadKnownFaces();
                } catch (error) {
                    showStatus(document.getElementById('dbStatus'), 'Error: ' + error.message, 'error');
                }
            }
        }

        // Health Check
        async function checkHealth() {
            const healthText = document.getElementById('healthText');
            const spinner = document.getElementById('healthSpinner');
            const statusBadge = document.getElementById('statusBadge');
            const facesChip = document.getElementById('facesChip');
            const webcamChip = document.getElementById('webcamChip');
            const dbChip = document.getElementById('dbChip');
            const modelChip = document.getElementById('modelChip');
            const diskChip = document.getElementById('diskChip');
            const uptimeChip = document.getElementById('uptimeChip');
            const cpuFill = document.getElementById('cpuFill');
            const memFill = document.getElementById('memFill');
            try {
                spinner.style.display = 'block';
                healthText.textContent = 'Checking system...';
                const response = await fetch('/api/health');
                const data = await response.json();
                // Format uptime HH:MM:SS
                const uptimeSec = Math.floor(data.uptime_seconds || 0);
                const hh = String(Math.floor(uptimeSec / 3600)).padStart(2, '0');
                const mm = String(Math.floor((uptimeSec % 3600) / 60)).padStart(2, '0');
                const ss = String(uptimeSec % 60).padStart(2, '0');
                const uptime = `${hh}:${mm}:${ss}`;

                const summary = data.simple || {};
                const statusText = summary.ok ? '‚úì OK' : (data.status === 'ok' ? '‚úì OK' : '‚úó ' + (data.status || 'unknown'));
                    const facesText = data.known_faces || 0;
                const cpuVal = (data.cpu_percent !== null && data.cpu_percent !== undefined) ? Math.round(Math.max(0, Math.min(100, data.cpu_percent))) : null;
                const memVal = (data.memory_percent !== null && data.memory_percent !== undefined) ? Math.round(Math.max(0, Math.min(100, data.memory_percent))) : null;
                const webcamText = data.webcam_available ? 'Yes' : 'No';

                // Update simpler visual elements
                if (summary.ok) {
                    statusBadge.className = 'status-badge ok';
                    statusBadge.textContent = 'OK';
                } else {
                    statusBadge.className = data.status === 'ok' ? 'status-badge ok' : 'status-badge err';
                    statusBadge.textContent = data.status === 'ok' ? 'OK' : 'ERROR';
                }
                facesChip.textContent = facesText;
                webcamChip.textContent = webcamText;
                dbChip.textContent = data.database_loaded ? 'Yes' : 'No';
                modelChip.textContent = data.model ? (data.model.length > 24 ? data.model.slice(0,21) + '...' : data.model) : 'N/A';
                diskChip.textContent = data.disk_free_gb !== null && data.disk_free_gb !== undefined ? `${data.disk_free_gb} GB` : 'N/A';
                uptimeChip.textContent = summary.uptime || uptime || 'N/A';
                // Set fills (bounded 0..100)
                if (cpuVal !== null) {
                    cpuFill.style.width = cpuVal + '%';
                    cpuFill.style.background = cpuVal > 80 ? '#dc3545' : cpuVal > 60 ? '#ffc107' : '#28a745';
                    cpuFill.title = `${cpuVal}%`;
                } else {
                    cpuFill.style.width = '0%';
                    cpuFill.title = 'N/A';
                }
                if (memVal !== null) {
                    memFill.style.width = memVal + '%';
                    memFill.style.background = memVal > 80 ? '#dc3545' : memVal > 60 ? '#ffc107' : '#28a745';
                    memFill.title = `${memVal}%`;
                } else {
                    memFill.style.width = '0%';
                    memFill.title = 'N/A';
                }
                // Set a very brief human-friendly health text (compact)
                healthText.innerHTML = `${statusText} ‚Ä¢ Faces: ${facesText}`;
            } catch (error) {
                healthText.className = 'status-message error';
                healthText.textContent = 'Error: ' + (error.message || String(error));
            } finally {
                spinner.style.display = 'none';
            }
        }

        // Helper Functions
        function showStatus(element, message, type) {
            element.textContent = message;
            element.className = `status-message ${type}`;
        }

        function displayImageResults(data, container) {
                const html = `
                <div class="results-container">
                    <h3>Results</h3>
                    <p><strong>Total Faces Detected:</strong> ${data.data.total_faces}</p>
                    <div>
                        ${data.data.recognized_faces.map(face => `
                            <div class="recognized-face">
                                <span class="name">${face.name}</span>
                                <span class="confidence">(${(face.confidence * 100).toFixed(1)}% confidence)</span>
                            </div>
                        `).join('')}
                    </div>
                    <h4 class="section-title">Annotated Image:</h4>
                    <img class="max-full rounded mt-10" src="${data.image}">
                </div>
            `;
            container.innerHTML = html;
        }

        async function displayVideoResults(data, container) {
                const html = `
                <div class="results-container">
                    <h3>Video Analysis Results</h3>
                    <p><strong>Total Frames:</strong> ${data.total_frames}</p>
                    <p><strong>Total Recognized Faces:</strong> ${data.total_recognized}</p>
                    <h4 class="section-title">Recognized People:</h4>
                    ${Object.keys(data.recognized_faces).length === 0 ? 
                        '<p class="muted">No recognized faces found in video</p>' :
                        Object.entries(data.recognized_faces).map(([name, count]) => `
                            <div class="recognized-face">
                                <span class="name">${name}</span>
                                <span class="confidence">${count} detection${count !== 1 ? 's' : ''}</span>
                            </div>
                        `).join('')
                    }
                    <h4 class="section-title">Annotated Video:</h4>
                    <video id="resultVideo" width="100%" controls preload="metadata" class="rounded mt-10">Your browser does not support the video tag.</video>
                    <div class="mt-10">
                        <a id="videoStaticLink" href="" target="_blank">Abrir v√≠deo em nova aba (fallback)</a>
                    </div>
                </div>
            `;
            container.innerHTML = html;

            // Try fetching the video as a Blob and use Object URL for playback.
            // This provides a fallback if the browser isn't making range requests properly.
            try {
                console.log('Video URL (API):', data.video_url, 'Static URL:', data.video_static_url);
                const resp = await fetch(data.video_static_url);
                if (resp.ok) {
                    const blob = await resp.blob();
                    const videoEl = container.querySelector('#resultVideo');
                    const url = URL.createObjectURL(blob);
                    if (videoEl) {
                        console.log('Fetched video blob with content-type', resp.headers.get('content-type'));
                        videoEl.src = url;
                        videoEl.onerror = () => { console.error('Video element error', videoEl.error); };
                        videoEl.onloadedmetadata = () => { console.log('video duration:', videoEl.duration, 'width', videoEl.videoWidth, 'height', videoEl.videoHeight); };
                    }
                const link = container.querySelector('#videoStaticLink');
                if (link) { link.href = data.video_static_url; }
                } else {
                    console.error('Failed to fetch video', resp.status, resp.statusText);
                    // Try setting static URL directly as the src (no blob)
                    const videoEl = container.querySelector('#resultVideo');
                    if (videoEl) {
                        videoEl.src = data.video_static_url;
                        console.warn('Used static URL as fallback for playback');
                    }
                }
            } catch (err) {
                console.error('Error loading video blob:', err);
            }
        }

        // Load known faces on page load
        window.addEventListener('load', () => {
            loadKnownFaces();
            checkHealth();
            initHealthConfig();
        });

        function toggleHealthConfig() {
            const cfg = document.getElementById('healthConfig');
            if (cfg.classList.contains('hidden')) {
                cfg.classList.remove('hidden');
            } else {
                cfg.classList.add('hidden');
            }
        }

        function initHealthConfig(){
            const cfgMap = ['faces','webcam','db','model','disk','uptime'];
            const saved = JSON.parse(localStorage.getItem('healthConfig') || '{}');
            cfgMap.forEach(k => {
                const box = document.getElementById('cfg_' + k);
                if (!box) return;
                box.checked = saved[k] !== undefined ? saved[k] : true;
                box.addEventListener('change', () => saveAndApplyConfig(cfgMap));
            });
            const iconBox = document.getElementById('cfg_icon_only');
            const iconOnlySaved = saved['icon_only'] || false;
            iconBox.checked = iconOnlySaved;
            iconBox.addEventListener('change', () => saveAndApplyConfig(cfgMap));
            applyConfigToUI(saved, cfgMap, iconOnlySaved);
        }

        function saveAndApplyConfig(cfgMap){
            const cfg = {};
            cfgMap.forEach(k => { cfg[k] = document.getElementById('cfg_' + k).checked });
            cfg.icon_only = document.getElementById('cfg_icon_only').checked;
            localStorage.setItem('healthConfig', JSON.stringify(cfg));
            applyConfigToUI(cfg, cfgMap, cfg.icon_only);
        }

        function applyConfigToUI(cfg, cfgMap, iconOnly){
            // Toggle chips
            cfgMap.forEach(k => {
                const chip = document.querySelector(`.status-chip[data-type="${k}"]`);
                if (!chip) return;
                if (cfg && cfg[k] === false) {
                    chip.style.display = 'none';
                } else {
                    chip.style.display = 'inline-flex';
                }
            });
            // Toggle icon-only mode
            const simple = document.getElementById('healthSimple');
            if (iconOnly) {
                simple.classList.add('icon-only');
            } else {
                simple.classList.remove('icon-only');
            }
        }
    </script>
</body>
</html>
